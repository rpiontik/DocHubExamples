# Начало работы над архитектурой

Чтобы каким то образом, хотя бы начать работать с архитектурой, и шире с архитектурными решениями требуется выполнить ряд шагов "в собственной голове", а также в инструментарии архитектора, и основная проблема - это **как начать**

Если вы придете к архитекторам или шире "к лицам принимающим архитектурные решения" - они вам будут рассказывать абстрактные истории про "TOGAF, Archimate и о том что существуют магические Enterprise архитекторы, которые... делают страшное". Но, для того чтобы начать - вам важно понимать другое:

* нужно создать файлы исходного кода
* нужно собрать файлы исходного кода
* нужно скомпилировать и развернуть файлы исходного кода 
* вы получите продукт "архитектура редакции 0.1.0"

И вот вы уже человек принимающий архитектурные решения.

## Настройка инструментария и создание репозитория

Для начала нужно настроить окружение разработчика. Правильные пацаны и девчонки любят следующие консольные утилиты

* **git** - это консольная утилита для работы с исходным кодом
* **make** - это консольная утилита для выполнения задач создания чего-либо из исходников

> Примечание: для Windows рабочей станции крайне рекомендуется использовать WSL2 и соответственно тогда установка данных утилит у вас займет минимум времени (на примере Debian - это будет выглядеть вот так `apt install git make`)

Опять же правильные пацаны и девчонки любят следующие IDE:

* [VSCodium](https://vscodium.com/) c пятью расширениями
    * [dochub-beta](https://t.me/c/1750057593/395)
    * [markdown](https://open-vsx.org/extension/shd101wyy/markdown-preview-enhanced)
    * [yaml](https://open-vsx.org/extension/redhat/vscode-yaml)
    * [conventionalcommits](https://open-vsx.org/extension/vivaxy/vscode-conventional-commits)
    * [languagetool-linter](https://open-vsx.org/extension/davidlday/languagetool-linter)

**Шаг -1 (минус один)** - нужно сделать себе GIT репозиторий и открыть его в интегрированной среде разработки (IDE вы же помните как расшифровывается ?)

команды достаточно простые:

```
mkdir arc42pilot
cd arc42pilot
git init .
codium .
```

По сути - создадим каталог, и инициализируем в нем "чистый git репозиторий"

> Если лично вы любите продукты JetBrains в качестве IDE, Вы конечно же помните что, оно слишком много скрывает. Поэтому можете использовать их продукты, но в инструкцию их установку добавлять не хочется. Ведь они нам не платят за их рекламу, как и Microsoft за рекламу VSCode

## Подготовка глоссария

Архитекторы выбирают точку отсчета - что болит больше всего... Обычно предлагается взять "систему" как основу. Причем в выборе системы вы скорее всего ошибетесь... Потому что это и не система окажется.

**Шаг 0:** Формирование требования - зачем вам архитектура как код. Самому себе.

Как вы помните, кодирование у нас начинается с требования и первым требованием которое мы советуем вам закодировать - :
* **Что за хренью вы занимаетесь, что вы сейчас разрабатываете и для кого.**. 

Возможно вы прямо сейчас творите "страшное и великое, и нельзя называть это хренью" - но в нашем случае главное начать

## Структура каталога архитектурного репозитория

**Шаг 1:** Поэтому начинать нужно с файла. Первого файла "Введение", точнее главных настроек. Пусть будет файл [dochub.yaml](./dochub.yaml) - так что создайте его, если он не создан. 
Еще нам понадобятся внутри репозитория еще 3 файла, а всего их будет 4-ре (четыре). 

* [./src/README.md](./src/README.md)
* [./src/root.yaml](./src/root.yaml)
* [./src/docs/root.yaml](./src/docs/root.yaml)

## Ваш первый коммит в архитектуру

Чтобы сделать первый коммит и как следствие первый релиз - вам нужно получить первое графическое представление контекста для которого вы строите архитектуру. Архитектура такая прикольная штука - что слово "контекст" это абстракция, которую вы можете интерпретировать как хотите.

По сути вы должны определить **с какого ракурса** вы хотите показать свою архитектуру - для этого вам понадобится определить "Аспект" (аспект - слово непонятное, неудобное и слишком абстрактное, поэтому действуйте от "ожидаемой схемы").

Чтобы понять - аспекты, контексты и другие непонятные слова, вам лучше начать с компонентов которые вы хотите отобразить на схеме

**Шаг 2:** 

Создадим компоненты, которые у нас буду участвовать на схемке и импортируем его внутрь файла с введением
Пусть их будет 4 классических для MVC приложения

* сама система с ее бизнес названием `enterprise.system.accounting`
* ее клиентская часть `enterprise.system.accounting.standaloneclient`
* ее серверный контейнер `enterprise.system.accounting.backendlogic`
* ее хранилище данных ``enterprise.system.accounting.database` 

что будет выглядеть в виде **YAML** c нужными нам реквизитами

```
components:
  enterprise.systems.accounting: 
    title: Бухгалтерия предприятия
  enterprise.systems.accounting.standaloneclient:
    title: Клиентское окно сотрудника бухгалтерии
  enterprise.systems.accounting.backendlogic:
    title: Серверная логика системы бухгалтерского учета
  enterprise.systems.accounting.database:
    title: Хранилище данных (СУБД) бухгалтерского учета  

```

**Ключевой момент на этом шаге - это придумать идентификаторы ваших компонентов. Здесь вам понадобится мозг**

сделайте первое упражнение `git add * && git commit -m "добавлены компоненты учетной системы"`

## Уже развертывание и компиляция (правда локальное)

**Шаг 3** Теперь, как и в случае с разработкой нам необходимо проверить локальное развертывание нашей архитектуры. Для этого нам понадобится DockerDaemon установленный локально (или в подсистеме WSL2)

И команда:

```
docker run --rm -p 38080:8080 \
 -v ./src:/usr/share/nginx/html/documentation \
 ghcr.io/rabotaru/dochub:v2.6.2
```

Однако можно и нужно проще. Выполните простую команду и разверните свою первую архитектуру

```
make develop
```

Раз вы разрабатываете архитектуру - то нужно же автоматически тестировать. И тестировать нужно, в том числе на развёртываемость. Тут есть несколько особенностей:

* Сам DocHub при локальном подключении ожидает адрес манифеста [./src/root.yaml](./src/root.yaml) относительно каталога nginx. Потому что, он собственно собран на базе Nginx образа Docker.
* Cам DocHub при локальном подключении пытается "построить архитектуру самого себя" и это нужно отключать - зачем вам его архитектура - вы же свою строите. Поэтому мы и подключаем в режиме монтирования наши исходники архитектуры вместо внутренней `./src -> /usr/share/nginx/html/documentation` через технологию блочных устройств Docker

И тут вас интересуют первые не пройденные тесты - http://localhost:38080/problems, и здесь вы обнаружите еще одно непонятное слово "Метамодель", это в довесок к "Контекстам и Аспектам"... И тут надо привыкать к архитектурным абстракциям. Дело в том что виденье по архитектуре - состоит из "сущностей" на каждой из слоев". И вот типы этих сущностей и способы их отображения - это и есть метамодель. Занимаясь моделированием метаданных архитектуры - вы и создаете свою архитектуру... Но... Это слишком абстрактно, поэтому нас интересует 2 вида проблем

* `компоненты вне контекста`
* `компоненты без корневого компонента`

## Чиним первые упавшие тесты, сиречь проблемы

**Шаг 4**: Теперь бы нам поправить, проблемы - и по сути "компоненты без корневого компоненты" тонко вам указывают на связи внешнего окружения - компоненты же не живут в вакууме... И чинить это просто, например так

```
components:
  enterprise: # Корневой компонент (домен)
    title: Холдинг "Замечательный"
  enterprise.systems:
    title: Системы учета хозяйственных операций
  enterprise.systems.accounting: 
    title: Бухгалтерия предприятия
  enterprise.systems.accounting.standaloneclient:
    title: Клиентское окно сотрудника бухгалтерии
  enterprise.systems.accounting.backendlogic:
    title: Серверная логика системы бухгалтерского учета
  enterprise.systems.accounting.database:
    title: Хранилище данных (СУБД) бухгалтерского учета  

```

* Мы добавили 2 верхне уровневых компонента - само предприятие, и класс систем... Нам сейчас так захотелось и это хорошо... Если мы ошиблись - мы поправим это потом.

А вот с контекстом интересней, потому что это то как вы хотите посмотреть/показать другим свою архитектуру. Сейчас сделаем самое простое упражнение - нам теперь надо отобразить "Все наши учетные системы"

создадим файл [./src/contexts/root.yaml](./src/contexts/root.yaml) и добавим в него магию представления

```
contexts:
  arch.all.systems:
    title: Все наши системы 
    location: Верхнеуровневый прикладной ландшафт/Холдинг Замечательный
    components:
      - enterprise.systems.*
  arch.accounting.systems:
    title: Все наши системы 
    location: Системный ландшафт/Бухгалтерские системы
    components:
      - *.systems.accounting.*
```

и не забудем импортировать в наш корневой файл [./src/root.yaml](./src/root.yaml) наши контексты представления

```
imports:
- contexts/root.yaml
```

Теперь у нас есть архитектура http://localhost:8080/architect/components/enterprise (не забудьте снова сделать локальный деплой и коммит)

## Из чего эта штука состоит

Это круто что у нас есть архитектура, но нам нужно явно указать какие у нас там технологии. И это товарищи ваш первый внутренний "холивар" - как их категоризировать, НО - раз мы кодируем то давайте создадим файл

**Шаг 4**: Подключим технологии уже из внешнего файла

* [./src/techstack/root.yaml](./src/techstack/root.yaml)

А из чего состоят наши компоненты ? Что за технологический набор (стэк) технологий мы используем. И тут рекомендуется сделать просто - прописать те технологии которые мы знаем. Создадим их:

```
technologies:
  sections:
    user.clients:
      title: Клиенты доступа
    lowcode.platforms:
      title: Платформы конструкторы пользовательских приложений
    databases.platforms:
      title: Платформы для построения СУБД
  items:    
    framework.electron:
      title: Electron
      section: user.clients
      status: trial
    platform.corteza:
      title: platform.corteza
      section: lowcode.platforms
      status: assess
    postgres.zombodb:
      title: ZomboDB
      section: databases.platforms
      status: adopt
```

Не забудем импортировать файл с нашим стэком в главный файл-манифест архитектуры

```
imports:
- techstack/root.yaml
```

И конечно укажем **технологии для наших компонентов**

* framework.electron - `Клиентское окно сотрудника бухгалтерии`
* platform.corteza - `Серверная логика системы бухгалтерского учета`
* postgres.zombodb - `Хранилище данных (СУБД) бухгалтерского учета`

В итоге наш корневой файл

`cat src/root.yaml`

будет выглядеть следующим образом

```
imports:
- contexts/root.yaml
- techstack/root.yaml

components:
  enterprise: # Корневой компонент (домен)
    title: Холдинг "Замечательный"
  enterprise.systems:
    title: Системы учета хозяйственных операций
  enterprise.systems.accounting: 
    title: Бухгалтерия предприятия
  enterprise.systems.accounting.standaloneclient:
    title: Клиентское окно сотрудника бухгалтерии
    technologies:
    - framework.electron
  enterprise.systems.accounting.backendlogic:
    title: Серверная логика системы бухгалтерского учета
    technologies:
    - platform.corteza
  enterprise.systems.accounting.database:
    title: Хранилище данных (СУБД) бухгалтерского учета
    technologies: 
    - postgres.zombodb

```

Как вы видите - у нас уже есть **Компоненты, Контексты и Технологии** и все они с идентификаторами и заголовками (Не забудьте снова сделать локальный деплой и коммит)


## Аспектно, контекстно, документно ориентированное программирование

Мы с вами уже заимели - контекст отображения, компоненты и технологии, осталось добавить документацию и аспекты (чтобы это не значило).
Начнем с самого тяжелого - **"аспект"** - на самом деле если смотреть гуманитарные науки, то аспект

**Шаг 5**: Нужно ответить себе на вопрос - в каком аспекте вы собираетесь рассматривать свои компоненты. Даже лучше **с какого ракурса**

>

## Собираем и деплоим

* закажите себе доменное имя для вашего хаба - например https://arc42hub.sec.example.com и ресурсы для развертывания Docker не более 2 CPU/2Gb RAM - этого будет достаточно и попросите людей с ценностями DevOps (или сами) развернуть вам там DocHub. Для этого вам понадобится выпустить релиз

**Шаг 6**: Релизим архитектуру в виде дистрибутива.

Нам понадобится сделать следующее

* создайте файл IMAGES-REPO.env и добавьте в него адрес хранилища Docker образов (публичный, корпоративный - не важно) в формате команды `export IMAGES_NAMESPACE="ghcr.io/rabotaru"`
* запустите сборку `make build` и опубликуйте ваш дистрибутив архитектуры `make publish`

## Что дальше

* определите для себя и для своей команды цель которую вы хотите достичь инструментом - цель краткосрочная: например описать ИТ ландшафт, **чтобы он был понятен даже младшему инженеру** - не замахивайтесь на глобальное, запутаетесь в стратегии.
* рисуйте на совещаниях и обсуждения "скетчи архитектуры" в Draw.IO и Miro - они могут стать основой для вашей структуры
* коммитьТе чаще и делайте деплой "раз в сутки", рассылайте ссылку на ваш портал ArcHub имеющим право "подумать над архитектурой".
* коммитьТе даже во время совещаний - не забывайте что есть **feature-branch**
* читайте "документацию по самому Dochub и вступайте в группу чудесных архитекторов и задавайте "вопрос"
* если у вас есть знания по vue.js, node 16+ и git+docker - попробуйте поконтрибьютить в сам проект ;-) 
* PROFFIT - выпускайте релизы архитектуры
